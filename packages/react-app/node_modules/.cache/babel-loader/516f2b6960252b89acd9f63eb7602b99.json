{"ast":null,"code":"var _objectSpread = require(\"C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar ethUtil = require('ethereumjs-util');\n\nvar ethAbi = require('ethereumjs-abi');\n\nvar nacl = require('tweetnacl');\n\nnacl.util = require('tweetnacl-util');\nvar TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string'\n            },\n            type: {\n              type: 'string'\n            }\n          },\n          required: ['name', 'type']\n        }\n      }\n    },\n    primaryType: {\n      type: 'string'\n    },\n    domain: {\n      type: 'object'\n    },\n    message: {\n      type: 'object'\n    }\n  },\n  required: ['types', 'primaryType', 'domain', 'message']\n};\n/**\n * A collection of utility functions used for signing typed data\n */\n\nvar TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData: function encodeData(primaryType, data, types) {\n    var _this = this;\n\n    var useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var encodedTypes = ['bytes32'];\n    var encodedValues = [this.hashType(primaryType, types)];\n\n    if (useV4) {\n      var encodeField = function encodeField(name, type, value) {\n        if (types[type] !== undefined) {\n          return ['bytes32', value === null || value === undefined ? '0x0000000000000000000000000000000000000000000000000000000000000000' : ethUtil.keccak(_this.encodeData(type, value, types, useV4))];\n        }\n\n        if (value === undefined) {\n          throw new Error(\"missing value for field \".concat(name, \" of type \").concat(type));\n        }\n\n        if (type === 'bytes') {\n          return ['bytes32', ethUtil.keccak(value)];\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8');\n          }\n\n          return ['bytes32', ethUtil.keccak(value)];\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          var parsedType = type.slice(0, type.lastIndexOf('['));\n          var typeValuePairs = value.map(function (item) {\n            return encodeField(name, parsedType, item);\n          });\n          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(typeValuePairs.map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 1),\n                _type = _ref2[0];\n\n            return _type;\n          }), typeValuePairs.map(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n                _value = _ref4[1];\n\n            return _value;\n          })))];\n        }\n\n        return [type, value];\n      };\n\n      var _iterator = _createForOfIteratorHelper(types[primaryType]),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n\n          var _encodeField = encodeField(field.name, field.type, data[field.name]),\n              _encodeField2 = _slicedToArray(_encodeField, 2),\n              type = _encodeField2[0],\n              value = _encodeField2[1];\n\n          encodedTypes.push(type);\n          encodedValues.push(value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else {\n      var _iterator2 = _createForOfIteratorHelper(types[primaryType]),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _field = _step2.value;\n          var _value2 = data[_field.name];\n\n          if (_value2 !== undefined) {\n            if (_field.type === 'bytes') {\n              encodedTypes.push('bytes32');\n              _value2 = ethUtil.keccak(_value2);\n              encodedValues.push(_value2);\n            } else if (_field.type === 'string') {\n              encodedTypes.push('bytes32'); // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n\n              if (typeof _value2 === 'string') {\n                _value2 = Buffer.from(_value2, 'utf8');\n              }\n\n              _value2 = ethUtil.keccak(_value2);\n              encodedValues.push(_value2);\n            } else if (types[_field.type] !== undefined) {\n              encodedTypes.push('bytes32');\n              _value2 = ethUtil.keccak(this.encodeData(_field.type, _value2, types, useV4));\n              encodedValues.push(_value2);\n            } else if (_field.type.lastIndexOf(']') === _field.type.length - 1) {\n              throw new Error('Arrays currently unimplemented in encodeData');\n            } else {\n              encodedTypes.push(_field.type);\n              encodedValues.push(_value2);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    return ethAbi.rawEncode(encodedTypes, encodedValues);\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType: function encodeType(primaryType, types) {\n    var result = '';\n    var deps = this.findTypeDependencies(primaryType, types).filter(function (dep) {\n      return dep !== primaryType;\n    });\n    deps = [primaryType].concat(deps.sort());\n\n    var _iterator3 = _createForOfIteratorHelper(deps),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var type = _step3.value;\n        var children = types[type];\n\n        if (!children) {\n          throw new Error(\"No type definition specified: \".concat(type));\n        }\n\n        result += \"\".concat(type, \"(\").concat(types[type].map(function (_ref5) {\n          var name = _ref5.name,\n              _type = _ref5.type;\n          return \"\".concat(_type, \" \").concat(name);\n        }).join(','), \")\");\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return result;\n  },\n\n  /**\n   * Finds all types within a type defintion object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies: function findTypeDependencies(primaryType, types) {\n    var results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    var _primaryType$match = primaryType.match(/^[0-9A-Z_a-z]*/),\n        _primaryType$match2 = _slicedToArray(_primaryType$match, 1),\n        firstWord = _primaryType$match2[0];\n\n    primaryType = firstWord;\n\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results;\n    }\n\n    results.push(primaryType);\n\n    var _iterator4 = _createForOfIteratorHelper(types[primaryType]),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var field = _step4.value;\n\n        var _iterator5 = _createForOfIteratorHelper(this.findTypeDependencies(field.type, types, results)),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var dep = _step5.value;\n            !results.includes(dep) && results.push(dep);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return results;\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashStruct: function hashStruct(primaryType, data, types) {\n    var useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4));\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType: function hashType(primaryType, types) {\n    return ethUtil.keccak(this.encodeType(primaryType, types));\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData: function sanitizeData(data) {\n    var sanitizedData = {};\n\n    for (var _i = 0, _Object$keys = Object.keys(TYPED_MESSAGE_SCHEMA.properties); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n      data[key] && (sanitizedData[key] = data[key]);\n    }\n\n    if (sanitizedData.types) {\n      sanitizedData.types = _objectSpread({\n        EIP712Domain: []\n      }, sanitizedData.types);\n    }\n\n    return sanitizedData;\n  },\n\n  /**\n   * Signs a typed message as per EIP-712 and returns its keccak hash\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - keccak hash of the resulting signed message\n   */\n  sign: function sign(typedData) {\n    var useV4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var sanitizedData = this.sanitizeData(typedData);\n    var parts = [Buffer.from('1901', 'hex')];\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n    }\n\n    return ethUtil.keccak(Buffer.concat(parts));\n  }\n};\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA: TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils: TypedDataUtils,\n  concatSig: function concatSig(v, r, s) {\n    var rSig = ethUtil.fromSigned(r);\n    var sSig = ethUtil.fromSigned(s);\n    var vSig = ethUtil.bufferToInt(v);\n    var rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64);\n    var sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64);\n    var vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig));\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex');\n  },\n  normalize: function normalize(input) {\n    if (!input) {\n      return undefined;\n    }\n\n    if (typeof input === 'number') {\n      var buffer = ethUtil.toBuffer(input);\n      input = ethUtil.bufferToHex(buffer);\n    }\n\n    if (typeof input !== 'string') {\n      var msg = 'eth-sig-util.normalize() requires hex string or integer input.';\n      msg += \" received \".concat(typeof input, \": \").concat(input);\n      throw new Error(msg);\n    }\n\n    return ethUtil.addHexPrefix(input.toLowerCase());\n  },\n  personalSign: function personalSign(privateKey, msgParams) {\n    var message = ethUtil.toBuffer(msgParams.data);\n    var msgHash = ethUtil.hashPersonalMessage(message);\n    var sig = ethUtil.ecsign(msgHash, privateKey);\n    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n    return serialized;\n  },\n  recoverPersonalSignature: function recoverPersonalSignature(msgParams) {\n    var publicKey = getPublicKeyFor(msgParams);\n    var sender = ethUtil.publicToAddress(publicKey);\n    var senderHex = ethUtil.bufferToHex(sender);\n    return senderHex;\n  },\n  extractPublicKey: function extractPublicKey(msgParams) {\n    var publicKey = getPublicKeyFor(msgParams);\n    return \"0x\".concat(publicKey.toString('hex'));\n  },\n  typedSignatureHash: function typedSignatureHash(typedData) {\n    var hashBuffer = _typedSignatureHash(typedData);\n\n    return ethUtil.bufferToHex(hashBuffer);\n  },\n  signTypedDataLegacy: function signTypedDataLegacy(privateKey, msgParams) {\n    var msgHash = _typedSignatureHash(msgParams.data);\n\n    var sig = ethUtil.ecsign(msgHash, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignatureLegacy: function recoverTypedSignatureLegacy(msgParams) {\n    var msgHash = _typedSignatureHash(msgParams.data);\n\n    var publicKey = recoverPublicKey(msgHash, msgParams.sig);\n    var sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  },\n  encrypt: function encrypt(receiverPublicKey, msgParams, version) {\n    switch (version) {\n      case 'x25519-xsalsa20-poly1305':\n        {\n          if (typeof msgParams.data === 'undefined') {\n            throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ');\n          } // generate ephemeral keypair\n\n\n          var ephemeralKeyPair = nacl.box.keyPair(); // assemble encryption parameters - from string to UInt8\n\n          var pubKeyUInt8Array;\n\n          try {\n            pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey);\n          } catch (err) {\n            throw new Error('Bad public key');\n          }\n\n          var msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data);\n          var nonce = nacl.randomBytes(nacl.box.nonceLength); // encrypt\n\n          var encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey); // handle encrypted data\n\n          var output = {\n            version: 'x25519-xsalsa20-poly1305',\n            nonce: nacl.util.encodeBase64(nonce),\n            ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),\n            ciphertext: nacl.util.encodeBase64(encryptedMessage)\n          }; // return encrypted msg data\n\n          return output;\n        }\n\n      default:\n        throw new Error('Encryption type/version not supported');\n    }\n  },\n  encryptSafely: function encryptSafely(receiverPublicKey, msgParams, version) {\n    var DEFAULT_PADDING_LENGTH = Math.pow(2, 11);\n    var NACL_EXTRA_BYTES = 16;\n    var data = msgParams.data;\n\n    if (!data) {\n      throw new Error('Cannot encrypt empty msg.data');\n    }\n\n    if (typeof data === 'object' && data.toJSON) {\n      // remove toJSON attack vector\n      // TODO, check all possible children\n      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');\n    } // add padding\n\n\n    var dataWithPadding = {\n      data: data,\n      padding: ''\n    }; // calculate padding\n\n    var dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');\n    var modVal = dataLength % DEFAULT_PADDING_LENGTH;\n    var padLength = 0; // Only pad if necessary\n\n    if (modVal > 0) {\n      padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes\n    }\n\n    dataWithPadding.padding = '0'.repeat(padLength);\n    var paddedMsgParams = {\n      data: JSON.stringify(dataWithPadding)\n    };\n    return this.encrypt(receiverPublicKey, paddedMsgParams, version);\n  },\n  decrypt: function decrypt(encryptedData, receiverPrivateKey) {\n    switch (encryptedData.version) {\n      case 'x25519-xsalsa20-poly1305':\n        {\n          // string to buffer to UInt8Array\n          var recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey);\n          var recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey; // assemble decryption parameters\n\n          var nonce = nacl.util.decodeBase64(encryptedData.nonce);\n          var ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext);\n          var ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey); // decrypt\n\n          var decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey); // return decrypted msg data\n\n          var output;\n\n          try {\n            output = nacl.util.encodeUTF8(decryptedMessage);\n          } catch (err) {\n            throw new Error('Decryption failed.');\n          }\n\n          if (output) {\n            return output;\n          }\n\n          throw new Error('Decryption failed.');\n        }\n\n      default:\n        throw new Error('Encryption type/version not supported.');\n    }\n  },\n  decryptSafely: function decryptSafely(encryptedData, receiverPrivateKey) {\n    var dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey));\n    return dataWithPadding.data;\n  },\n  getEncryptionPublicKey: function getEncryptionPublicKey(privateKey) {\n    var privateKeyUint8Array = nacl_decodeHex(privateKey);\n    var encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;\n    return nacl.util.encodeBase64(encryptionPublicKey);\n  },\n\n  /**\n   * A generic entry point for all typed data methods to be passed, includes a version parameter.\n   */\n  signTypedMessage: function signTypedMessage(privateKey, msgParams) {\n    var version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'V4';\n\n    switch (version) {\n      case 'V1':\n        return this.signTypedDataLegacy(privateKey, msgParams);\n\n      case 'V3':\n        return this.signTypedData(privateKey, msgParams);\n\n      case 'V4':\n      default:\n        return this.signTypedData_v4(privateKey, msgParams);\n    }\n  },\n  recoverTypedMessage: function recoverTypedMessage(msgParams) {\n    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'V4';\n\n    switch (version) {\n      case 'V1':\n        return this.recoverTypedSignatureLegacy(msgParams);\n\n      case 'V3':\n        return this.recoverTypedSignature(msgParams);\n\n      case 'V4':\n      default:\n        return this.recoverTypedSignature_v4(msgParams);\n    }\n  },\n  signTypedData: function signTypedData(privateKey, msgParams) {\n    var message = TypedDataUtils.sign(msgParams.data, false);\n    var sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  signTypedData_v4: function signTypedData_v4(privateKey, msgParams) {\n    var message = TypedDataUtils.sign(msgParams.data);\n    var sig = ethUtil.ecsign(message, privateKey);\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));\n  },\n  recoverTypedSignature: function recoverTypedSignature(msgParams) {\n    var message = TypedDataUtils.sign(msgParams.data, false);\n    var publicKey = recoverPublicKey(message, msgParams.sig);\n    var sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  },\n  recoverTypedSignature_v4: function recoverTypedSignature_v4(msgParams) {\n    var message = TypedDataUtils.sign(msgParams.data);\n    var publicKey = recoverPublicKey(message, msgParams.sig);\n    var sender = ethUtil.publicToAddress(publicKey);\n    return ethUtil.bufferToHex(sender);\n  }\n};\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\n\nfunction _typedSignatureHash(typedData) {\n  var error = new Error('Expect argument to be non-empty array');\n\n  if (typeof typedData !== 'object' || !typedData.length) {\n    throw error;\n  }\n\n  var data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value;\n  });\n  var types = typedData.map(function (e) {\n    return e.type;\n  });\n  var schema = typedData.map(function (e) {\n    if (!e.name) {\n      throw error;\n    }\n\n    return \"\".concat(e.type, \" \").concat(e.name);\n  });\n  return ethAbi.soliditySHA3(['bytes32', 'bytes32'], [ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema), ethAbi.soliditySHA3(types, data)]);\n}\n\nfunction recoverPublicKey(hash, sig) {\n  var signature = ethUtil.toBuffer(sig);\n  var sigParams = ethUtil.fromRpcSig(signature);\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s);\n}\n\nfunction getPublicKeyFor(msgParams) {\n  var message = ethUtil.toBuffer(msgParams.data);\n  var msgHash = ethUtil.hashPersonalMessage(message);\n  return recoverPublicKey(msgHash, msgParams.sig);\n}\n\nfunction padWithZeroes(number, length) {\n  var myString = \"\".concat(number);\n\n  while (myString.length < length) {\n    myString = \"0\".concat(myString);\n  }\n\n  return myString;\n} // converts hex strings to the Uint8Array format used by nacl\n\n\nfunction nacl_decodeHex(msgHex) {\n  var msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');\n  return nacl.util.decodeBase64(msgBase64);\n}","map":{"version":3,"sources":["C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/node_modules/burner-provider/node_modules/eth-sig-util/index.js"],"names":["require","Buffer","ethUtil","ethAbi","nacl","util","TYPED_MESSAGE_SCHEMA","type","properties","types","additionalProperties","items","name","required","primaryType","domain","message","TypedDataUtils","encodeData","data","useV4","encodedTypes","encodedValues","hashType","encodeField","value","undefined","keccak","Error","from","lastIndexOf","length","parsedType","slice","typeValuePairs","map","item","rawEncode","_type","_value","field","push","encodeType","result","deps","findTypeDependencies","filter","dep","concat","sort","children","join","results","match","firstWord","includes","hashStruct","sanitizeData","sanitizedData","Object","keys","key","EIP712Domain","sign","typedData","parts","module","exports","concatSig","v","r","s","rSig","fromSigned","sSig","vSig","bufferToInt","rStr","padWithZeroes","toUnsigned","toString","sStr","vStr","stripHexPrefix","intToHex","addHexPrefix","normalize","input","buffer","toBuffer","bufferToHex","msg","toLowerCase","personalSign","privateKey","msgParams","msgHash","hashPersonalMessage","sig","ecsign","serialized","recoverPersonalSignature","publicKey","getPublicKeyFor","sender","publicToAddress","senderHex","extractPublicKey","typedSignatureHash","hashBuffer","signTypedDataLegacy","recoverTypedSignatureLegacy","recoverPublicKey","encrypt","receiverPublicKey","version","ephemeralKeyPair","box","keyPair","pubKeyUInt8Array","decodeBase64","err","msgParamsUInt8Array","decodeUTF8","nonce","randomBytes","nonceLength","encryptedMessage","secretKey","output","encodeBase64","ephemPublicKey","ciphertext","encryptSafely","DEFAULT_PADDING_LENGTH","NACL_EXTRA_BYTES","toJSON","dataWithPadding","padding","dataLength","byteLength","JSON","stringify","modVal","padLength","repeat","paddedMsgParams","decrypt","encryptedData","receiverPrivateKey","recieverPrivateKeyUint8Array","nacl_decodeHex","recieverEncryptionPrivateKey","fromSecretKey","decryptedMessage","open","encodeUTF8","decryptSafely","parse","getEncryptionPublicKey","privateKeyUint8Array","encryptionPublicKey","signTypedMessage","signTypedData","signTypedData_v4","recoverTypedMessage","recoverTypedSignature","recoverTypedSignature_v4","error","e","schema","soliditySHA3","Array","fill","hash","signature","sigParams","fromRpcSig","ecrecover","number","myString","msgHex","msgBase64"],"mappings":"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","sourcesContent":["const { Buffer } = require('buffer')\nconst ethUtil = require('ethereumjs-util')\nconst ethAbi = require('ethereumjs-abi')\nconst nacl = require('tweetnacl')\nnacl.util = require('tweetnacl-util')\n\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: { type: 'string' },\n            type: { type: 'string' },\n          },\n          required: ['name', 'type'],\n        },\n      },\n    },\n    primaryType: { type: 'string' },\n    domain: { type: 'object' },\n    message: { type: 'object' },\n  },\n  required: ['types', 'primaryType', 'domain', 'message'],\n}\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData (primaryType, data, types, useV4 = true) {\n    const encodedTypes = ['bytes32']\n    const encodedValues = [this.hashType(primaryType, types)]\n\n    if (useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value === null || value === undefined ?\n            '0x0000000000000000000000000000000000000000000000000000000000000000' :\n            ethUtil.keccak(this.encodeData(type, value, types, useV4))]\n        }\n\n        if (value === undefined) {\n          throw new Error(`missing value for field ${name} of type ${type}`)\n        }\n\n        if (type === 'bytes') {\n          return ['bytes32', ethUtil.keccak(value)]\n        }\n\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8')\n          }\n          return ['bytes32', ethUtil.keccak(value)]\n        }\n\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['))\n          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))\n          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(\n            typeValuePairs.map(([_type]) => _type),\n            typeValuePairs.map(([, _value]) => _value),\n          ))]\n        }\n\n        return [type, value]\n      }\n\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name])\n        encodedTypes.push(type)\n        encodedValues.push(value)\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name]\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32')\n            value = ethUtil.keccak(value)\n            encodedValues.push(value)\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32')\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8')\n            }\n            value = ethUtil.keccak(value)\n            encodedValues.push(value)\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32')\n            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))\n            encodedValues.push(value)\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData')\n          } else {\n            encodedTypes.push(field.type)\n            encodedValues.push(value)\n          }\n        }\n      }\n    }\n\n    return ethAbi.rawEncode(encodedTypes, encodedValues)\n  },\n\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType (primaryType, types) {\n    let result = ''\n    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)\n    deps = [primaryType].concat(deps.sort())\n    for (const type of deps) {\n      const children = types[type]\n      if (!children) {\n        throw new Error(`No type definition specified: ${type}`)\n      }\n      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`\n    }\n    return result\n  },\n\n  /**\n   * Finds all types within a type defintion object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies (primaryType, types, results = []) {\n    const [firstWord] = primaryType.match(/^\\w*/u)\n    primaryType = firstWord\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results\n    }\n    results.push(primaryType)\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep)\n      }\n    }\n    return results\n  },\n\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashStruct (primaryType, data, types, useV4 = true) {\n    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))\n  },\n\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType (primaryType, types) {\n    return ethUtil.keccak(this.encodeType(primaryType, types))\n  },\n\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData (data) {\n    const sanitizedData = {}\n    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {\n      data[key] && (sanitizedData[key] = data[key])\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }\n    }\n    return sanitizedData\n  },\n\n  /**\n   * Signs a typed message as per EIP-712 and returns its keccak hash\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - keccak hash of the resulting signed message\n   */\n  sign (typedData, useV4 = true) {\n    const sanitizedData = this.sanitizeData(typedData)\n    const parts = [Buffer.from('1901', 'hex')]\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))\n    }\n    return ethUtil.keccak(Buffer.concat(parts))\n  },\n}\n\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n\n  concatSig (v, r, s) {\n    const rSig = ethUtil.fromSigned(r)\n    const sSig = ethUtil.fromSigned(s)\n    const vSig = ethUtil.bufferToInt(v)\n    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)\n    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)\n    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))\n    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')\n  },\n\n  normalize (input) {\n    if (!input) {\n      return undefined\n    }\n\n    if (typeof input === 'number') {\n      const buffer = ethUtil.toBuffer(input)\n      input = ethUtil.bufferToHex(buffer)\n    }\n\n    if (typeof input !== 'string') {\n      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'\n      msg += ` received ${typeof input}: ${input}`\n      throw new Error(msg)\n    }\n\n    return ethUtil.addHexPrefix(input.toLowerCase())\n  },\n\n  personalSign (privateKey, msgParams) {\n    const message = ethUtil.toBuffer(msgParams.data)\n    const msgHash = ethUtil.hashPersonalMessage(message)\n    const sig = ethUtil.ecsign(msgHash, privateKey)\n    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n    return serialized\n  },\n\n  recoverPersonalSignature (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams)\n    const sender = ethUtil.publicToAddress(publicKey)\n    const senderHex = ethUtil.bufferToHex(sender)\n    return senderHex\n  },\n\n  extractPublicKey (msgParams) {\n    const publicKey = getPublicKeyFor(msgParams)\n    return `0x${publicKey.toString('hex')}`\n  },\n\n  typedSignatureHash (typedData) {\n    const hashBuffer = typedSignatureHash(typedData)\n    return ethUtil.bufferToHex(hashBuffer)\n  },\n\n  signTypedDataLegacy (privateKey, msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data)\n    const sig = ethUtil.ecsign(msgHash, privateKey)\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n  },\n\n  recoverTypedSignatureLegacy (msgParams) {\n    const msgHash = typedSignatureHash(msgParams.data)\n    const publicKey = recoverPublicKey(msgHash, msgParams.sig)\n    const sender = ethUtil.publicToAddress(publicKey)\n    return ethUtil.bufferToHex(sender)\n  },\n\n  encrypt (receiverPublicKey, msgParams, version) {\n\n    switch (version) {\n      case 'x25519-xsalsa20-poly1305': {\n        if (typeof msgParams.data === 'undefined') {\n          throw new Error('Cannot detect secret message, message params should be of the form {data: \"secret message\"} ')\n        }\n        // generate ephemeral keypair\n        const ephemeralKeyPair = nacl.box.keyPair()\n\n        // assemble encryption parameters - from string to UInt8\n        let pubKeyUInt8Array\n        try {\n          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)\n        } catch (err) {\n          throw new Error('Bad public key')\n        }\n\n        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)\n        const nonce = nacl.randomBytes(nacl.box.nonceLength)\n\n        // encrypt\n        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)\n\n        // handle encrypted data\n        const output = {\n          version: 'x25519-xsalsa20-poly1305',\n          nonce: nacl.util.encodeBase64(nonce),\n          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),\n          ciphertext: nacl.util.encodeBase64(encryptedMessage),\n        }\n        // return encrypted msg data\n        return output\n      }\n      default:\n        throw new Error('Encryption type/version not supported')\n\n    }\n  },\n\n  encryptSafely (receiverPublicKey, msgParams, version) {\n\n    const DEFAULT_PADDING_LENGTH = (2 ** 11)\n    const NACL_EXTRA_BYTES = 16\n\n    const { data } = msgParams\n    if (!data) {\n      throw new Error('Cannot encrypt empty msg.data')\n    }\n\n    if (typeof data === 'object' && data.toJSON) {\n      // remove toJSON attack vector\n      // TODO, check all possible children\n      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')\n    }\n\n    // add padding\n    const dataWithPadding = {\n      data,\n      padding: '',\n    }\n\n    // calculate padding\n    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')\n    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)\n    let padLength = 0\n    // Only pad if necessary\n    if (modVal > 0) {\n      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes\n    }\n    dataWithPadding.padding = '0'.repeat(padLength)\n\n    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }\n    return this.encrypt(receiverPublicKey, paddedMsgParams, version)\n  },\n\n  decrypt (encryptedData, receiverPrivateKey) {\n\n    switch (encryptedData.version) {\n      case 'x25519-xsalsa20-poly1305': {\n        // string to buffer to UInt8Array\n        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)\n        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey\n\n        // assemble decryption parameters\n        const nonce = nacl.util.decodeBase64(encryptedData.nonce)\n        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)\n        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)\n\n        // decrypt\n        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)\n\n        // return decrypted msg data\n        let output\n        try {\n          output = nacl.util.encodeUTF8(decryptedMessage)\n        } catch (err) {\n          throw new Error('Decryption failed.')\n        }\n\n        if (output) {\n          return output\n        }\n        throw new Error('Decryption failed.')\n      }\n\n      default:\n        throw new Error('Encryption type/version not supported.')\n    }\n  },\n\n  decryptSafely (encryptedData, receiverPrivateKey) {\n    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))\n    return dataWithPadding.data\n  },\n\n\n  getEncryptionPublicKey (privateKey) {\n    const privateKeyUint8Array = nacl_decodeHex(privateKey)\n    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey\n    return nacl.util.encodeBase64(encryptionPublicKey)\n  },\n\n\n  /**\n   * A generic entry point for all typed data methods to be passed, includes a version parameter.\n   */\n  signTypedMessage (privateKey, msgParams, version = 'V4') {\n    switch (version) {\n      case 'V1':\n        return this.signTypedDataLegacy(privateKey, msgParams)\n      case 'V3':\n        return this.signTypedData(privateKey, msgParams)\n      case 'V4':\n      default:\n        return this.signTypedData_v4(privateKey, msgParams)\n    }\n  },\n\n  recoverTypedMessage (msgParams, version = 'V4') {\n    switch (version) {\n      case 'V1':\n        return this.recoverTypedSignatureLegacy(msgParams)\n      case 'V3':\n        return this.recoverTypedSignature(msgParams)\n      case 'V4':\n      default:\n        return this.recoverTypedSignature_v4(msgParams)\n    }\n  },\n\n  signTypedData (privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false)\n    const sig = ethUtil.ecsign(message, privateKey)\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n  },\n\n  signTypedData_v4 (privateKey, msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data)\n    const sig = ethUtil.ecsign(message, privateKey)\n    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))\n  },\n\n  recoverTypedSignature (msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data, false)\n    const publicKey = recoverPublicKey(message, msgParams.sig)\n    const sender = ethUtil.publicToAddress(publicKey)\n    return ethUtil.bufferToHex(sender)\n  },\n\n  recoverTypedSignature_v4 (msgParams) {\n    const message = TypedDataUtils.sign(msgParams.data)\n    const publicKey = recoverPublicKey(message, msgParams.sig)\n    const sender = ethUtil.publicToAddress(publicKey)\n    return ethUtil.bufferToHex(sender)\n  },\n\n}\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHash (typedData) {\n  const error = new Error('Expect argument to be non-empty array')\n  if (typeof typedData !== 'object' || !typedData.length) {\n    throw error\n  }\n\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value\n  })\n  const types = typedData.map(function (e) {\n    return e.type\n  })\n  const schema = typedData.map(function (e) {\n    if (!e.name) {\n      throw error\n    }\n    return `${e.type} ${e.name}`\n  })\n\n  return ethAbi.soliditySHA3(\n    ['bytes32', 'bytes32'],\n    [\n      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),\n      ethAbi.soliditySHA3(types, data),\n    ],\n  )\n}\n\nfunction recoverPublicKey (hash, sig) {\n  const signature = ethUtil.toBuffer(sig)\n  const sigParams = ethUtil.fromRpcSig(signature)\n  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)\n}\n\nfunction getPublicKeyFor (msgParams) {\n  const message = ethUtil.toBuffer(msgParams.data)\n  const msgHash = ethUtil.hashPersonalMessage(message)\n  return recoverPublicKey(msgHash, msgParams.sig)\n}\n\n\nfunction padWithZeroes (number, length) {\n  let myString = `${number}`\n  while (myString.length < length) {\n    myString = `0${myString}`\n  }\n  return myString\n}\n\n// converts hex strings to the Uint8Array format used by nacl\nfunction nacl_decodeHex (msgHex) {\n  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')\n  return nacl.util.decodeBase64(msgBase64)\n}\n\n\n"]},"metadata":{},"sourceType":"script"}