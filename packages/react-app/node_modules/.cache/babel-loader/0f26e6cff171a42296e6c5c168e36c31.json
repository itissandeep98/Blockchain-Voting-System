{"ast":null,"code":"import _regeneratorRuntime from\"C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _toConsumableArray from\"C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _asyncToGenerator from\"C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useState}from\"react\";import useOnBlock from\"./OnBlock\";import usePoller from\"./Poller\";var DEBUG=false;/*\r\n  ~ What it does? ~\r\n\r\n  Enables you to read values from contracts and keep track of them in the local React states\r\n\r\n  ~ How can I use? ~\r\n\r\n  const purpose = useContractReader(readContracts,\"YourContract\", \"purpose\")\r\n\r\n  ~ Features ~\r\n\r\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\r\n  - Specify the name of the contract, in this case it is \"YourContract\"\r\n  - Specify the name of the variable in the contract, in this case we keep track of \"purpose\" variable\r\n  - Pass an args array if the function requires\r\n  - Pass pollTime - if no pollTime is specified, the function will update on every new block\r\n*/export default function useContractReader(contracts,contractName,functionName,args,pollTime,formatter,onChange){var _this=this;var adjustPollTime=0;if(pollTime){adjustPollTime=pollTime;}else if(!pollTime&&typeof args===\"number\"){// it's okay to pass poll time as last argument without args for the call\nadjustPollTime=args;}var _useState=useState(),_useState2=_slicedToArray(_useState,2),value=_useState2[0],setValue=_useState2[1];var _useState3=useState(false),_useState4=_slicedToArray(_useState3,2),tried=_useState4[0],setTried=_useState4[1];useEffect(function(){if(typeof onChange===\"function\"){setTimeout(onChange.bind(_this,value),1);}},[value,onChange]);var updateValue=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var newValue,_contracts$contractNa;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;if(DEBUG)console.log(\"CALLING \",contractName,functionName,\"with args\",args);if(!(args&&args.length>0)){_context.next=10;break;}_context.next=5;return(_contracts$contractNa=contracts[contractName])[functionName].apply(_contracts$contractNa,_toConsumableArray(args));case 5:newValue=_context.sent;setTried(true);if(DEBUG)console.log(\"contractName\",contractName,\"functionName\",functionName,\"args\",args,\"RESULT:\",newValue);_context.next=14;break;case 10:_context.next=12;return contracts[contractName][functionName]();case 12:newValue=_context.sent;setTried(true);case 14:if(formatter&&typeof formatter===\"function\"){newValue=formatter(newValue);}// console.log(\"GOT VALUE\",newValue)\nif(newValue!==value){setValue(newValue);}_context.next=21;break;case 18:_context.prev=18;_context.t0=_context[\"catch\"](0);console.log(_context.t0);case 21:case\"end\":return _context.stop();}}},_callee,null,[[0,18]]);}));return function updateValue(){return _ref.apply(this,arguments);};}();// Only pass a provider to watch on a block if we have a contract and no PollTime\nuseOnBlock(contracts&&contracts[contractName]&&adjustPollTime===0&&contracts[contractName].provider,function(){if(contracts&&contracts[contractName]&&adjustPollTime===0){if(DEBUG)console.log(\"on-blocking!\",contractName,functionName);updateValue();}});// Use a poller if a pollTime is provided\nusePoller(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(){return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(contracts&&contracts[contractName]&&adjustPollTime>0){if(DEBUG)console.log(\"polling!\",contractName,functionName);updateValue();}case 1:case\"end\":return _context2.stop();}}},_callee2);})),adjustPollTime,contracts&&contracts[contractName]);if(tried===false&&contracts&&contracts[contractName]){updateValue();}return value;}","map":{"version":3,"sources":["C:/Users/KINSHUK/Desktop/ETH/qd-off-chain-voters-and-candidates/packages/react-app/src/hooks/ContractReader.js"],"names":["useEffect","useState","useOnBlock","usePoller","DEBUG","useContractReader","contracts","contractName","functionName","args","pollTime","formatter","onChange","adjustPollTime","value","setValue","tried","setTried","setTimeout","bind","updateValue","console","log","length","newValue","provider"],"mappings":"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","sourcesContent":["import { useEffect, useState } from \"react\";\r\nimport useOnBlock from \"./OnBlock\";\r\nimport usePoller from \"./Poller\";\r\n\r\nconst DEBUG = false;\r\n\r\n/*\r\n  ~ What it does? ~\r\n\r\n  Enables you to read values from contracts and keep track of them in the local React states\r\n\r\n  ~ How can I use? ~\r\n\r\n  const purpose = useContractReader(readContracts,\"YourContract\", \"purpose\")\r\n\r\n  ~ Features ~\r\n\r\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\r\n  - Specify the name of the contract, in this case it is \"YourContract\"\r\n  - Specify the name of the variable in the contract, in this case we keep track of \"purpose\" variable\r\n  - Pass an args array if the function requires\r\n  - Pass pollTime - if no pollTime is specified, the function will update on every new block\r\n*/\r\n\r\nexport default function useContractReader(contracts, contractName, functionName, args, pollTime, formatter, onChange) {\r\n  let adjustPollTime = 0;\r\n  if (pollTime) {\r\n    adjustPollTime = pollTime;\r\n  } else if (!pollTime && typeof args === \"number\") {\r\n    // it's okay to pass poll time as last argument without args for the call\r\n    adjustPollTime = args;\r\n  }\r\n\r\n  const [value, setValue] = useState();\r\n  const [tried, setTried] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (typeof onChange === \"function\") {\r\n      setTimeout(onChange.bind(this, value), 1);\r\n    }\r\n  }, [value, onChange]);\r\n\r\n  const updateValue = async () => {\r\n    try {\r\n      let newValue;\r\n      if (DEBUG) console.log(\"CALLING \", contractName, functionName, \"with args\", args);\r\n      if (args && args.length > 0) {\r\n        newValue = await contracts[contractName][functionName](...args);\r\n        setTried(true);\r\n        if (DEBUG)\r\n          console.log(\"contractName\", contractName, \"functionName\", functionName, \"args\", args, \"RESULT:\", newValue);\r\n      } else {\r\n        newValue = await contracts[contractName][functionName]();\r\n        setTried(true);\r\n      }\r\n      if (formatter && typeof formatter === \"function\") {\r\n        newValue = formatter(newValue);\r\n      }\r\n      // console.log(\"GOT VALUE\",newValue)\r\n      if (newValue !== value) {\r\n        setValue(newValue);\r\n      }\r\n    } catch (e) {\r\n      console.log(e);\r\n    }\r\n  };\r\n\r\n  // Only pass a provider to watch on a block if we have a contract and no PollTime\r\n  useOnBlock(contracts && contracts[contractName] && adjustPollTime === 0 && contracts[contractName].provider, () => {\r\n    if (contracts && contracts[contractName] && adjustPollTime === 0) {\r\n      if (DEBUG) console.log(\"on-blocking!\", contractName, functionName);\r\n      updateValue();\r\n    }\r\n  });\r\n\r\n  // Use a poller if a pollTime is provided\r\n  usePoller(\r\n    async () => {\r\n      if (contracts && contracts[contractName] && adjustPollTime > 0) {\r\n        if (DEBUG) console.log(\"polling!\", contractName, functionName);\r\n        updateValue();\r\n      }\r\n    },\r\n    adjustPollTime,\r\n    contracts && contracts[contractName],\r\n  );\r\n\r\n  if (tried === false && contracts && contracts[contractName]) {\r\n    updateValue();\r\n  }\r\n\r\n  return value;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}